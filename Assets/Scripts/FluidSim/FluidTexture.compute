#pragma kernel CSMain

RWTexture2D<float4> Result;
StructuredBuffer<float> U;
StructuredBuffer<float> V;
StructuredBuffer<float> Density;
StructuredBuffer<float> Pressure;
StructuredBuffer<float> Vorticity;
StructuredBuffer<int> Solid;
StructuredBuffer<float> R;
StructuredBuffer<float> G;
StructuredBuffer<float> B;

Texture2D<float4> VelocityLUT;
Texture2D<float4> PressureLUT;
Texture2D<float4> VorticityLUT;

SamplerState sampler_VelocityLUT;
SamplerState sampler_PressureLUT;
SamplerState sampler_VorticityLUT;

int Width;
int Height;
int textureWidth;
int textureHeight;
float CellSize;
float MaxVelocityMag;
float MaxDensity;
float MaxPressureMag;
float MaxVorticityMag;
float4 solidCellColor;
float4 backgroundColor;
uint visualizationMode;

// Sample cell-centered data (density, pressure, vorticity)
float sampleCellCentered(StructuredBuffer<float> buf, float2 worldPos)
{
    // Convert world to grid coordinates (cell-centered)
    float gridX = worldPos.x / CellSize - 0.5;
    float gridY = worldPos.y / CellSize - 0.5;
    
    int x0 = clamp(floor(gridX), 0, Width - 1);
    int x1 = clamp(x0 + 1, 0, Width - 1);
    int y0 = clamp(floor(gridY), 0, Height - 1);
    int y1 = clamp(y0 + 1, 0, Height - 1);
    
    float sx = gridX - x0;
    float sy = gridY - y0;
    
    float c00 = buf[x0 + y0 * Width];
    float c10 = buf[x1 + y0 * Width];
    float c01 = buf[x0 + y1 * Width];
    float c11 = buf[x1 + y1 * Width];
    
    float c0 = lerp(c00, c10, sx);
    float c1 = lerp(c01, c11, sx);
    
    return lerp(c0, c1, sy);
}

// Sample U velocity (staggered: offset in Y)
float sampleU(float2 worldPos)
{
    float gridX = worldPos.x / CellSize;
    float gridY = worldPos.y / CellSize - 0.5;
    
    int x0 = clamp(floor(gridX), 0, Width);
    int x1 = clamp(x0 + 1, 0, Width);
    int y0 = clamp(floor(gridY), 0, Height - 1);
    int y1 = clamp(y0 + 1, 0, Height - 1);
    
    float sx = gridX - x0;
    float sy = gridY - y0;
    
    float c00 = U[x0 + y0 * (Width + 1)];
    float c10 = U[x1 + y0 * (Width + 1)];
    float c01 = U[x0 + y1 * (Width + 1)];
    float c11 = U[x1 + y1 * (Width + 1)];
    
    float c0 = lerp(c00, c10, sx);
    float c1 = lerp(c01, c11, sx);
    
    return lerp(c0, c1, sy);
}

// Sample V velocity (staggered: offset in X)
float sampleV(float2 worldPos)
{
    float gridX = worldPos.x / CellSize - 0.5;
    float gridY = worldPos.y / CellSize;
    
    int x0 = clamp(floor(gridX), 0, Width - 1);
    int x1 = clamp(x0 + 1, 0, Width - 1);
    int y0 = clamp(floor(gridY), 0, Height);
    int y1 = clamp(y0 + 1, 0, Height);
    
    float sx = gridX - x0;
    float sy = gridY - y0;
    
    float c00 = V[x0 + y0 * Width];
    float c10 = V[x1 + y0 * Width];
    float c01 = V[x0 + y1 * Width];
    float c11 = V[x1 + y1 * Width];
    
    float c0 = lerp(c00, c10, sx);
    float c1 = lerp(c01, c11, sx);
    
    return lerp(c0, c1, sy);
}

float InverseLerp(float a, float b, float x)
{
    return (x - a) / (b - a);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= textureWidth || id.y >= textureHeight) return;
    
    float gridWidth = Width * CellSize;
    float gridHeight = Height * CellSize;
    
    // Pixel â†’ World position (exactly like CPU code)
    float worldX = (id.x + 0.5) * gridWidth / textureWidth;
    float worldY = (id.y + 0.5) * gridHeight / textureHeight;
    float2 worldPos = float2(worldX, worldY);
    
    // Check solid cells (exactly like CPU code)
    int cellI = clamp(floor(worldX / CellSize), 0, Width - 1);
    int cellJ = clamp(floor(worldY / CellSize), 0, Height - 1);
    
    if (Solid[cellI + cellJ * Width] == 1 && visualizationMode != 999)
    {
        Result[id.xy] = solidCellColor;
        return;
    }
    
    float4 color = float4(0, 0, 0, 1);
    
    if (visualizationMode == 0) // Velocity
    {
        float u = sampleU(worldPos);
        float v = sampleV(worldPos);
        float velMag = length(float2(u, v));
        
        float t = saturate(velMag / MaxVelocityMag);
        color = VelocityLUT.SampleLevel(sampler_VelocityLUT, float2(t, 0.5), 0);
    }
    else if (visualizationMode == 1) // Pressure
    {
        float pressure = sampleCellCentered(Pressure, worldPos);
        float t = saturate(abs(pressure) / MaxPressureMag);
        color = PressureLUT.SampleLevel(sampler_PressureLUT, float2(t, 0.5), 0);
    }
    else if (visualizationMode == 2) // Density/Smoke
    {
        float density = sampleCellCentered(Density, worldPos);
        float t = saturate(density / MaxDensity);
        color.rgb = lerp(backgroundColor.rgb, float3(1, 1, 1), t);
    }
    else if (visualizationMode == 3) // Vorticity
    {
        float vorticity = sampleCellCentered(Vorticity, worldPos);
        
        color = VorticityLUT.SampleLevel(sampler_VorticityLUT, float2(InverseLerp(-MaxVorticityMag, MaxVorticityMag, vorticity), 0.5), 0);
    }
    else if (visualizationMode == 4) // Pressure + Density
    {
        float pressure = sampleCellCentered(Pressure, worldPos);
        float density = sampleCellCentered(Density, worldPos);
        
        float t = saturate(abs(pressure) / MaxPressureMag);
        float3 pressureColor = PressureLUT.SampleLevel(sampler_PressureLUT, float2(t, 0.5), 0).rgb;
        
        float densityT = saturate(density / MaxDensity);
        color.rgb = lerp(backgroundColor.rgb, pressureColor, densityT);
    }
    else if (visualizationMode == 5) // Velocity + Density
    {
        float u = sampleU(worldPos);
        float v = sampleV(worldPos);
        float velMag = length(float2(u, v));
        
        float density = sampleCellCentered(Density, worldPos);
        
        float t = saturate(velMag / MaxVelocityMag);
        float3 velColor = VelocityLUT.SampleLevel(sampler_VelocityLUT, float2(t, 0.5), 0).rgb;
        
        float densityT = saturate(density / MaxDensity);
        color.rgb = lerp(backgroundColor.rgb, velColor, densityT);
    }
    else if (visualizationMode == 6) // Color
    {
        float density = sampleCellCentered(Density, worldPos);
        float r = sampleCellCentered(R, worldPos);
        float g = sampleCellCentered(G, worldPos);
        float b = sampleCellCentered(B, worldPos);

        float t = saturate(density / MaxDensity);
        color.rgb = lerp(backgroundColor.rgb, float3(r, g, b), t);
    }
    else if (visualizationMode == 999) // DEBUG
    {
        int cellI = clamp(floor(worldPos.x / CellSize), 0, Width - 1);
        int cellJ = clamp(floor(worldPos.y / CellSize), 0, Height - 1);
    
        // Show cell coordinates as colors
        float r = float(cellI) / float(Width);
        float g = float(cellJ) / float(Height);
        color = float4(r, g, 0, 1);
    
        // Solid cells in white
        if (Solid[cellI + cellJ * Width] == 1)
            color = float4(1, 1, 1, 1);
    }
    
    Result[id.xy] = color;
}